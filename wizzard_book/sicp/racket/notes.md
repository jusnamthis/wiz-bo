## Код как данные

"Lisp" расшифровывается как List processor (обработчик списков).

Односвязный список - основная структура данных в этих языках.

Более того, любая программа на Lisp - сама по себе список.

Например:

    (displayln "eat me") - это список из двух элементов: displayln и "eat me"

В этом проявляется одна из ключевых особенностей любого lisp-языка: код на Lisp одновременно
является данными Lisp-языка (говорят "код как данные").

Это свойство называется **гомоиконичностью** и является визитной карточкой данного семейства.

## Списки как дерево

Список - рекурсивная структура данных. Любой элемент может быть списком и содержать внутри себя элементы-списки.

Фактически получается, что исходный код на Racket - это древовидная структура.


## Формы

Любая корректная программа на Lisp - это форма.

    (+ 1 2) ; форма
    8 ; форма
    "hello" ; форма

Форм всего две - нормальная и соствная.

Нормальные формы вычисляются сами в себя - 8, "hello".

Составные формы список, который нужно обработать тем или иным способом (вычислить).

В Lisp-языках используется префиксная нотация, т.е первый элемент формы определяет поведение (семантику). 

## Объявление символов

    (define id expr)
    ; id - идентификатор
    ; expr - выражение

Например:

    ; define создаёт "объявление"
    (define lang "racket")
    (displayln lang) ; => racket

Значением объявления может быть как нормальная форма, так и составная:

    (define result (+ 7 (- 4 6))
    (displayln result) ; => 5

define связывает имя (идентификатор) и значение следующего за ним выражения.

Для изменения значения объявления используется функция set!:

    (set! lang "scheme")
    (displayln lang) ; => scheme

В общем случае использовать set! не рекомендуется. Racket отлично поддерживает функциональную парадигму и всячески её поощряет.
Код с переменными практически всегда легко заменяется на код с константами.


## Racket: создание и вызов функций

Функции в Racket обладают следующими свойствами:

* у функций нет имён. Во многих языках такие функции называются анонимными или лямбда-функциями;
* функции являются объектами первого рода. их можно присваивать переменным, передавать в другие функции и возвращать из функций.

Например:
    
    ;определение функции, вычисляющей сумму двух чисел
    (lambda (x y) (+ x y))

Определение функции начинается со слова lambda. Далее идёт список аргументов. Третий и последующий элементы - тело функции.
То есть тело может состоять из одной или нескольких форм.

    (lambda ()
     (displayln "one")`
     (displayln "two"))

Надо обратить внимание на отсутствие return.
В отличие от большинства других языков, в Lisp-языках инструкций практически нет.



