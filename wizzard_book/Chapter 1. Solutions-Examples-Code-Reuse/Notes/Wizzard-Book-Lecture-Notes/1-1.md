## 1.1. Элементы программирования.

Мы собираемся изучать понятие **вычислительного процесса** (**computational process**).
Вычислительные процессы - это абстрактные существа, которые живут в комьютерах. Развиваясь, процессы манипулируют абстракциями других типов, которые называются **данными** (**data**).
Эволюция процесса направляется набором правил, называемым **программой** (**program**).
**В сущности мы заколдовываем духов с помощью своих чар.**


Всякий язык программирования обладает тремя механизмами, преднанзначенными для манипуляции данными и их комбинирования:

1. **элементарные выражения**, представляющие собой минимальные сущности, с которыми язык имеет дело;
2. **средства комбинирования**, с помощью которых из элементарных выражений составляются сложные;
3. **средства абстракции**, с помощью которых сложные объекты можно называть и обращаться с ними как с единым целым.

В программировании мы имеем дело с двумя типами объектов: **процедурами** и **данными**.
**Данные** - это материал, который мы хотим обрабатывать.
**Процедуры** - набор правил обработки данных.

Таким образом от языка программирования требуется способность описывать элементарные данные и элементарные процедуры, а также возможность комбинирования и абстрации процедур и данных.

### 1.1.1. Выражения.

Вбивая в терминале:

	> 486 // INPUT: **выражение (expression)**
	486 // OUTPUT: **вычисление (evaluation)**

Выражения, представленные числами могут комбинироваться с использованием элементарных процедур (+, -) так, что получаются составные выражения, представляющие собой применение процедуры к этим числам:

	> (+ 50 100);
	150

Выражения такого рода, образуемые путём заключения списка выражений в скобки с целью обозначения применения функции к аргументам называется **комбинацией** (**combinations**).

Самый левый элемент комбинации, обозначающий применяемую функцию называется **оператором** (**operator**).
Остальные элементы называются **операндами**. (**operands**).

Значение комбинации вычисляется путём применения процедуры, задаваемой оператором к **аргументам** (**arguments**), задаваемым операндами.

Соглашение, по которому оператор ставится слева от операндов, известно как **префиксная нотация (prefix notation)**.

Работая со сложными выражениями, интерпретатор всегда ведёт себя одинаковым образом: он считывает выражение с терминала, вычисляет его и печатает результат. Этот способ работы называют **циклом чтение-вычисление-печать** (read-eval-print-loop).

### 1.1.2. Имена и окружение.

Мы говорим, что имя обозначает **переменную** (**variable**), чьим **значением** (**value**) является объект.

В диалекте LISP'а - Scheme мы даём имена вещам с помощью слова **define**.

	> (define size 2)

Выражение заставляет интерпретатор связать значением 2 с именем size.
После того, как значение было связано - мы можем указывать на значение через присвоенное имя.

	> size
	2

Слово **define** служит в языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций.

	> (define pi 3.1415926535)
	> (define radius 10)
	> (define circumference (* 2 pi radius))


Ясно, что раз интерпретатор способен ассоциировать значения с символами и затем вспоминать их, то он должен иметь некоторого рода память, сохраняющую пары имя-объект.
Эта память называется **окружением** (**environment**). А точнее **глобальным окружением** (**global environment**).

### 1.1.3. Вычисление комбинаций.

Одна из **целей** этой главы - **выделить элементы процдеурного мышления**.

Чтобы вычислить комбинацию требуется:

* вычислить все подвыражения комбинации;
* применить процедуру, которая является значением самого левого подвыражения (оператора) к аргументам - значениям остальных подвыражений (операндов).

На первом шаге, для того чтобы провести процесс вычисления комбинации, нужно сначала проделать процесс вычисления для каждого элемента комбинации. Таким образом, правило вычисления **рекурсивно (recursive)** по своей природе.

Стоит отметить какую краткость понятие рекурсии придаёт описанию того, что в случае с комбинацией с глубоким уровнем вложенности выглядело бы достаточно сложно.

Например, чтобы вычислить:

	(* (+ 2 (* 4 6))
		(+ 3 5 7))

требуется применить правило вычисления к четырём разным комбинациям.