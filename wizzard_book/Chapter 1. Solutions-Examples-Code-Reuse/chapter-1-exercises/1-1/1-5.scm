#lang simply-scheme

(define p (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 p)

; (if (= x 0)
;     0
;     (p)) аппликативный сломается/нормальный не попадёт

; Так как аппликативный порядок вычислений основан на том, что сначала подставляет все аргументы,
; и только после проводит вычисление - при попытке подставить p - программа попадёт в рекурсию без условия выхода,
; из-за чего аварийно завершится.

; При нормальном порядке вычислений ("не вычисляет аргументы, пока не понадобится их значение") программа выведет 0,
; поскольку предикат возвращает истину.